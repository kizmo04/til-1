# rest

Representational State Transfer
네트워크 아키텍쳐 원리모음

인터넷 상의 컴퓨터 시스템끼리 서로 연결해주는 아키텍쳐

HTTP 기반으로 필요한 자원에 접근하는 방식을 정해놓은 네트워크 아키텍쳐

> 자원
>
> 저장된 데이터는 물론, 이미지/동영상/문서와 같은 파일, 서비스(이메일 전송, 푸쉬 메시지 등)등을 포함

> 여기서 아키텍쳐란
>
> 시스템을 구축하기 위해서 전체 시스템에 대한 구조를 정의한 문서로, 시스템을 구성하는 컴포넌트와, 그 컴포넌트간의 관계, 그리고, 컴포넌트가 다루는 정보(데이터)를 정의한다

REST는 표준 프로토콜이 아닌 네트워트간 연동하는 방식을 정의해 놓은 개념

> 	`URI` 는 웹 상에 존재하는 어떤 자원의 주소이다. 경기도 안산시 상록구 사동이라는 주소를 가지는 곳은 지구상에서 단 한 곳인 것 처럼 URI는 웹 상에 존재하는 어떤 유일한 자원을 가리키는 주소이다.

인터넷 정보를 어떻게 공유할 것인가?

* 표현 방식: HTML
* 식별자: URI
* 전송 방법: HTTP

HTTP 프로토콜을 여러사람들이 설계를 하는데 이미 있는 웹이랑 호환성을 유지할 수 있을까 ? -> HTTP Object Model를 만든다.

> REST APIs must be hypertext-driven

> REST API를 위한 최고의 버저닝 전략은 버저닝을 안 하는 것

왜 필요한가? 

독립적인 진화를 위해서

* 서버와 클라이언트가 각각 독립적으로 진화한다.
* 서버의 기능이 변경되어도 클라이언트를 업데이트할 필요가 없다.
* "How do I improve HTTP without breaking the web"
* HTML 명세가 변경되어도 HTTP 명세가 변경되어도 웹은 잘 작동한다.

## REST의 6가지 제한 조건

이 제약조건을 준수하는 웹사이트를 RESTful 하다 라고 한다.

* 클라이언트 / 서버 구조

  * 클라이언트와 서버가 각각의 역할을 구분
  * 서버는 API를 제공, API 요청 시 비지니스 로직 처리와 데이터 저장을 책임. 클라이언트는 사용자 인증, 상태(세션, 로그인 정보)관리와 서버 리소스 요청을 책임지는 구조로 역할 구분(상호 의존성을 줄임)

* 무상태 (Stateless)

  * REST 서버는 작업을 위한 상태정보(세션, 쿠키 등)을 관리하지 않아야 함. 서버는 상태가 없다. 시스템 영향없이 관리 및 업데이트 가능
  * 만약 여러개의 서버가 병렬로 구성되어 있을 경우, 하나의 시스템이 문제가 되더라도 다른 시스템으로 접속해서 작업을 이어갈 수 있디.

* 캐시 처리 가능 (Cacheable)

  * HTTP 웹표준으로 HTTP가  가진 캐싱 기능이 적용된다.

* 계층화 (Layered System)

  * 서버를 다중 계층으로 구성할 수 있음
  * 비지니스 로직을 수행하는 API 서버와 그 앞단에 사용자 인증, 암호화 등의 계층을 추가해 구조상의 유연성을 제공

* Code on demand (Optional)

  * 서버에서 코드를 클라이언트로 보내서 실행할 수 있어야 한다.
  * 자바스크립트를 말한다.

* 인터페이스 일관성(Uniform interface)

  * 아키텍처를 단순화하고 분리해 각 부분을 독립적으로 발전 시킬 수 있음

  * 리소스가 uri로 식별된다.(Identification of resources)

  * ```shell
    http://www.example.com/v2/tasks # 할 일들의 collection
    http://www.example.com/v2/tasks/2 # id 값이 2인 할 일
    http://www.example.com/v2/tasks/14 # id 값이 14인 할 일
    ```

  * 

  * representations 전송을 통해서 리소스를 조작한다.(manifulation of resources through representations)

    * 리소스를 만들거나 삭제할때 HTTP 메시지에 그 표현을 담아서 전송한다.

  * **self-descriptive messages**

  * **hypermedia as the engine of application state (HATEOAS)**

**self-descriptive messages**

메시지는 스스로를 설명해야한다.

**HATEOAS**

애플리케이션의 상태는 Hyperlink를 이용해 전이되어야한다.
html에서 a태그를 이용하는 것이다.

json에 link라는 헤더를 이용할 수 잇다.

이미 HTTP 사이트에는 5가지 원칙이 녹아 들어가 있다.

우리는 route만 잘 쓰면 된다.

REST 하게 만든다 -> url 주소만 보고도 수행하려는 동작을 눈치챌 수 있게 만드는 것 

REST API
REST 아키텍쳐 스타일을 따르는 API
REST 
분산 하이퍼미디어 시스템을 위한 아키텍쳐 스타일
아키텍쳐 스타일
제약조건의 집합

## REST API

REST 기반으로 서비스 API 구현한 것을 REST API라고 한다.

최근 OPEN API, 마이크로 서비스(하나의 큰 애플리케이션을 여러 개의 작은 애플리케이션으로 쪼개어 변경과 조합이 가능하도록 만든 아키텍쳐) 등을 제공하는 업체 대부분은 REST API를 제공

사내 시스템들도 REST 기반으로 시스템을 분산해 확장성과 재사용성을 높여 유지보수 및 운용을 편리하게 할 수 있다.

REST는 HTTP 표준을 기반으로 구현하므로, HTTP를 지원하는 프로그램 언어로 클라이언트, 서버를 구현할 수 있다.

## REST 주요 구성요소

* 리소스: 접근할 대상, 어떠한 자원에 접근할 지 URI를 통해 식별
* 메소드: 리소스에 대한 행위, HTTP 메소드에 따라 자원에 접근(생성, 조회, 수정, 삭제)
* 메시지: HTTP 헤더와 바디에 포함된 메시지는 메시지를 처리하기 위한 충분한 정보를 포함

> 어떤 자원(리소스)에 어떤 행위(메소드)를 어떻게(메시지) 할 지 HTTP 기반으로 정해놓은 아키텍처 이다.

### 리소스  

url의 의미중 명사가 리소스, 동사를 메소드로 만든다.

| 메소드 /  리소스 / id | 의미               | 자원에 대한 행위   |
| --------------------- | ------------------ | ------------------ |
| GET /posts            | 글 목록을 봅니다.  | 자원 조회 (Read)   |
| POST /posts           | 글 을 생성합니다 . | 자원 생성 (Create) |
| PUT /posts/:id        | 글을 수정 합니다.  | 자원 수정 (Update) |
| DELETE /posts/:id     | 글을 삭제 합니다.  | 자원 삭제 (Delete) |

### 메소드

|        | 수행하기 전, 후 | 반복 수행한 결과 | 리소스 수 |
| ------ | --------------- | ---------------- | --------- |
| GET    | 같다            | 같다             | 같다      |
| POST   | 다르다          | 다르다           | 많아진다  |
| PUT    | 다르다          | 같다             | 같다      |
| DELETE | 다르다          | 다르다           | 적어진다  |

ID와 리소스 정보 이외의 정보를 url에 담으면 안된다.
이 이외에엔 파라미터로 넘겨준다.

```
put /dogs/1/isSick X
put /dogs/1?isSick=true
```

"무엇"(명사)을 생성하는지 생각해보아야 한다.

저장되는 정보가 무엇인지 생각한다.
로그인을 하는것은 세션이 저장되는 일이다.

```
POST /login x
POST /users/login x
POST /session o
```

### 메시지

REST에서 자원에 대한 정보는 HTTP 바디와 HTTP 헤더, 응답 상태코드를 활용합니다.

**HTTP 바디**

HTTP 바디에 포함된 데이터를 통해 자원에 대한 정보를 전달합니다.

데이터 포맷으로는 최근 JSON을 많이 사용하는 추세입니다. 

GET(조회) 요청 시 서버는 조건에 맞는 정보를 HTTP 바디에 담아 클라이언트에 응답할 수 있고, POST(생성), PUT(수정) 요청 시 클라이언트는 자원에 대한 정보를 요청 HTTP 바디에 담아 서버에 요청합니다.

**HTTP 헤더**

HTTP 바디의 컨텐츠 종류를 명시할 수 있으며, 헤더에 정의된 컨텐츠 타입에 따라 데이터를 분석하도록 구현합니다.

요청 HTTP 헤더는 "Accept" 항목으로, 응답 HTTP 헤더는 "Content-type"으로 컨텐츠 타입을 설명합니다.

Content-type

* application/json
* application/xml
* text/plain
* image/jpeg
* image/png

**응답 상태코드**

리소스 요청에 대한 응답은 응답 상태코드로 설명할 수 있다.

* 200 - 요청을 정상 수행
* 201 - 리소스 생성 요청 성공(POST로 생성 요청 시에 한함)
* 400 - 요청이 부적절함
* 401 - 인증되지 않은 상태에서 보호된 리소스 요청
* 403 - 공개되지 않은 리소스에 접근 요청(인증과 무관)
* 404 - 존재하지 않는 리소스 요청
* 406 - 지원하지 않는 미디어타입을 요청
* 409 - 리소스 상태에 의해 해당 요청을 수행하지 못함

## REST API 구현

델파이의 HTTP 라이브러리를 이용해 REST API를 구현할 수 있다.



```json
"_links" : {
  "self" : {
    "href" : "https://www.vanillacoding.co/"
  },
  "about" : {
    "href" : "/about"
  }
}
```

